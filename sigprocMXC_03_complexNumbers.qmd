```{python}
import numpy as np
import cmath
import math
import matplotlib.pyplot as plt
```

# From the number line to the complex number plane

The real number line is centered at 0, and stretches infinitely, containing all
numbers, both negative (left) and positive (right). On this line, each number
carries two pieces of information: its sign, and its magnitude, indicating
wether if its at the left or the right of 0, and how far it is. This mental
model is good for many cases, but there are problems in mathematics, physics, engineering, or signal processing that are more tractable working with a number
plane defined with a real, and an imaginary axis ($x$ and $y$, respectively).

The basis of the real axis is the number one, and the basis for the imaginary
axis is the operator $i = \sqrt{-1}$. It is called the imaginary operator
because there is not a quantity that actually exists because no squared number
can be negative. $i$ was created with the intent to solve $x^{2} + 1 = 0$,
where $x = i$.

For a long time, $i$ was considered a quirk in mathematics. However, Gauss
had the insight that we can take the imaginary operator and make that be a
basis for the complex plane.

The reason why the complex plane is really useful is that you can pack a lot of information into a single complex number which has a real and an imaginary part.
for example, in $2 + 3j$, $2$ is the real part, and $3$ corresponds to the
imaginary part (just $'3'$, not $'3j'$). These numbers also have a magnitude
representing their distance from the origin, and an angle.

Now I just want to show you the link between the geometric interpretation and
the algebraic interpretation.

## Complex numbers in Python

The imaginary operator can be written as $i$ or $j$. Mathematicians tend to
prefer the former, whereas engineers use the latter because $i$ is used for
electrical current intensity. In Python the imaginary operator is represented
with $j$, and also can be generated by taking the square root
of $-1$, or with the function `complex`.

In general, is advisable not to use just a letter because these are frequently
used in the context of for loops, overwriting the operator. However, if you try
to set $1i$ as anything else the interpreter will throw an error.

You can extract the real part using the function `np.real`, and the imaginary
part with `np.imag`.

```{python}
for z in [4 + 3j, 4 + 3 * 1j, 4 + 3 * cmath.sqrt(-1), complex(4,3)]:
    print(f"{z}, Real part is {np.real(z)}, imaginary part is {np.imag(z)}.")
```

## Plot a complex number

The real part is plotted based on the real axis, whereas the imaginary part
is plotted onto the imaginary axis. 

```{python}
plt.plot( np.real(z),np.imag(z),'rs' )
plt.plot([-5,5],[0,0],'k')
plt.plot([0,0],[-5,5],'k')
plt.axis([-5, 5, -5, 5])
plt.xlabel('Real axis')
plt.ylabel('Imaginary axis');
```

# Addition and subtraction with complex numbers

Think of to complex numbers, each with its own real and imaginary part. To add
or subtract these numbers, you just add or subtract each of their parts
independently, which returns the real and the imaginary parts of the result.

$$
z + w =
(z_{r} + i z_{i}) + (w_{r} + i w_{i}) =
(z_{r} + w_{r}) + (i z_{i} + i w_{i}) =
(z_{r} + w_{r}) + i(z_{i} + w_{i}) 
$$

If $z$ or $w$ is real valued, it is possible to follow the same procedure
substituting the imaginary part by 0

```{python}
# create two complex numbers
a = complex(4,5)
b = 3+2j

# Addition
print(a + b, '==', complex(np.real(a) + np.real(b) , np.imag(a) + np.imag(b)))

# subtraction
print(a - b, '==', complex(np.real(a) - np.real(b), np.imag(a) - np.imag(b)))
```

# Multiplication with complex numbers

Complex numbers are represented by two individual numbers, which is done by
multiplication expansion (cross product?). After the expansion the last term
contains $i^{2}$, which can be simplified to $-1$. The last step is to group
the real terms and the imaginary terms. 

The real part is the product of the two real parts minus the product of the
two imaginary parts, whereas the imaginary part is the two cross terms: the
imaginary part of the first number times the real part of the second number.

Nothing changes if a number is complex and the other is real-valued, however,
one of the imaginary parts would be $0$, meaning a pair of terms would drop
out.

$$
\begin{align}
    x \times w
    &= (z_{r} + i z_{i}) \times (w_{r} + iw_{i}) \\
    &= z_{r}w_{r} + z_{r}iw_{i} + i z_{i}w_{r} + i z_{i} i w_{i} \\
    &= z_{r}w_{r} + z_{r}iw_{i} + i z_{i}w_{r} + 
       \left( \sqrt{-1} \right)^{2} z_{i} w_{i} \\
    &= z_{r}w_{r} + z_{r}iw_{i} + i z_{i}w_{r} - z_{i}w_{i} \\
    &= (z_{r}w_r - z_{i}w_{i}) + (z_{r}iw_{i} + i z_{i}w_{r}) \\
    &= (z_{r}w_r - z_{i}w_{i}) + i (z_{r}w_{i} + z_{i}w_{r})
\end{align}
$$

```{python}
# the intuitive-but-WRONG way
print(complex( np.real(a)*np.real(b) , np.imag(a)*np.imag(b) ), '-- WRONG way!')

# the less-intuitive-but-CORRECT way
ar, ai = np.real(a), np.imag(a)
br, bi = np.real(b), np.imag(b)

print(
    a * b, '==',
    (ar * br) + (ar * (1j*bi)) + ((1j*ai) * br) + ((1j*ai) * (1j*bi)), '==',
    (ar + 1j*ai) * (br + 1j*bi)
    )
```

# The complex conjugate

The complex conjugate is often indicated using an asterisk in the superscript.
The operation itself only flips the sign of the imaginary part.

$$
\begin{align}
z &\rightarrow z^{*} \\
(a + ib) &\rightarrow (a-ib) \\
(a-ib) &\rightarrow (a+ib)
\end{align}
$$

```{python}
c = complex(4,-5)
print('c is', c, 'c* is', np.conj(c), '==', complex(np.real(c), -np.imag(c)))
```

There is a curious property of the complex conjugate, which is that if you
multiply a complex number by its complex conjugate, the result is the real part
squared plus the imaginary part squared.

$$
zz^{*} = (a + ib)(a - ib) = a ^{2} + aib - aib - (bi)^{2} = a^{2} + b^{2}
$$

$zz^{*}$ is called the magnitude squared of the complex number $z$. The
magnitude of $z$ can be extracted by just taking the square root. The magnitude
squared of a complex number also can be extracted by squaring the absolute
value of the number (see section on complex numbers as polar coordinates). 

Note when Python is used to calculate the magnitude squared with
`c * np.conj(c)` it returns an object of type `complex` even though the
imaginary part is 0. If it is done 'manually' or using the absolute value
the result is just a simple floating point number.

```{python}
print(
    c * np.conj(c), '==',
    np.real(c)**2 + np.imag(c)**2, '==',
    np.abs(c)**2
    )
```

# Division with complex numbers

The key insight to perform division with complex numbers is to remember that
a complex number times its conjugate is a real number. Thus, this division
problem can be solved by multiplying both nominator and denominator by the
complex conjugate of the latter, ensuring the denominator is just a real
number. Then, multiply the nominator of the complex conjugate of the original
denominator, and simplify.

$$
\begin{align}
\frac{z}{w}
    &= \frac{z_{r} + iz_{i}}{w_{r} + iw_{i}} \\
    &= \frac{(z_{r} + iz_{i})(w_{r} - iw_{i})}{(w_{r} + iw_{i})(w_{r} - iw_{i})} \\
    &= \frac{(z_{r} + iz_{i})w^{*}}{w^{2}_{r} + iw^{2}_{i}}
\end{align}
$$

In short

$$
\frac{z}{w} = \frac{z \times w^{*}}{w \times w^{*}}
$$

```{python}
# create two complex numbers
d = complex(4,-5)
e = complex(7,8)

# Division
print(d/e, '==', (d * np.conj(e)) / (e * np.conj(e)))
```

# Magnitude and phase of complex numbers

So far we have talked about the algebraic perspective of the complex numbers.
Now we are going to focus on their geometric perspective, treating the real
and imaginary parts as coordinates on a plane. This opens the possibility of
using trigonometry.

We are going to think about the complex number as a line connected to the
origin of the complex plane. If we think about this distance as the hypotenuse
of a triangle and the other two sides are the projection of the real and
imaginary parts into their respective axes.

Thus, this way we can calculate the length of the line and its angle relative
to the positive real axis. These two quantities are called the magnitude and
the phase (or argument) of the complex number. The magnitude can be calculated
as using pythagoras theorem, or simply using the complex conjugate.

$$
|z|^{2} = imag(z)^{2} + real(z)^{2} = zz^{*}
$$ 

The phase $\theta$ is the angle between line going from the origin to the
complex number, and the positive real axis. It can be calculated as

$$
\tan (\theta) = \frac{imag(z)}{real(z)}
\rightarrow
\theta = \arctan \frac{imag(z)}{real(z)} 
$$



![The complex plane](sigprocMXC_03_complexNumbers/ComplexCartesian.png)

## A complex number on the complex plane (cartesian or rectangular representation)

```{python}
# create a complex number
z = 4 + 3j

# plot the complex number
plt.plot(np.real(z), np.imag(z),'ks')

# make plot look nicer
plt.xlim([-5,5])
plt.ylim([-5,5])
plt.plot([-5,5],[0,0],'k')
plt.plot([0,0],[-5,5],'k')
plt.xlabel('real axis')
plt.ylabel('imag axis')
plt.show()
```

## Its magnitude and phase

```{python}
# magnitude of the number (distance to origin)
print(np.sqrt(np.real(z)**2 + np.imag(z)**2), '==', np.abs( z ))

# angle of the line relative to positive real axis
print(math.atan2(np.imag(z),np.real(z)), '==', np.angle(z))
```



## A complex number on the complex plane (polar or 'Euler' representation)

```{python}
# draw a line using polar notation
plt.polar([0, np.angle(z)], [0, np.abs(z)], 'r')

plt.show()
```